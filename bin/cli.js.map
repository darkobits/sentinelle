{"version":3,"sources":["../../src/bin/cli.ts"],"names":["initAdeiu","sentinelle","signal","log","info","chalk","bold","secondaryHandler","stop","process","off","kill","pid","prependListener","cli","command","builder","usage","positional","description","type","required","option","coerce","arg","Array","isArray","default","DEFAULT_KILL_SIGNAL","example","handler","argv","entrypoint","entry","bin","watch","processShutdownSignal","quiet","configure","level","on","err","verbose","isLevelAtLeast","version","prefix","green","start","error","message","stack","split","slice","join","exit","init"],"mappings":"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","sourcesContent":["#!/usr/bin/env node\n\nimport adeiu from '@darkobits/adeiu';\nimport cli from '@darkobits/saffron';\n\nimport {DEFAULT_KILL_SIGNAL} from 'etc/constants';\nimport {SentinelleArguments} from 'etc/types';\nimport SentinelleFactory from 'lib/sentinelle';\nimport log from 'lib/log';\nimport {getPackageVersion} from 'lib/utils';\n\n\n/**\n * Initializer for shutdown handlers.\n */\nconst initAdeiu = (sentinelle: ReturnType<typeof SentinelleFactory>) => adeiu(async signal => {\n  log.info(log.chalk.bold(`Got signal ${signal}; shutting-down.`));\n\n  // Register a second handler on the same signal we just received that\n  // will force-kill the process. This way, if a process is still within\n  // the grace period when the user issues a second SIGINT, for example,\n  // we just kill the process immediately and exit.\n  const secondaryHandler = async () => {\n    await sentinelle.stop('SIGKILL');\n\n    // Un-register this handler to prevent recursion.\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    process.off(signal, secondaryHandler);\n\n    // Kill the process with the same signal we received.\n    process.kill(process.pid, signal);\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  process.prependListener(signal, secondaryHandler);\n\n  await sentinelle.stop();\n});\n\n\n// ----- Command: Default ------------------------------------------------------\n\ncli.command<SentinelleArguments>({\n  command: '* <entrypoint>',\n  builder: ({command}) => {\n    command.usage('Run a process, watch for file changes, and re-start the process.');\n\n    command.positional('entrypoint', {\n      description: 'Entrypoint to the script/application to run.',\n      type: 'string',\n      required: true\n    });\n\n    command.option('bin', {\n      description: 'Optional binary (and any arguments to pass to it) to use to execute the entry file.',\n      type: 'string',\n      required: false\n    });\n\n    command.option('watch', {\n      description: 'Directory to watch for file changes. Defaults to the directory of the entry file.',\n      type: 'string',\n      coerce: arg => (Array.isArray(arg) ? arg : [arg]),\n      required: false\n    });\n\n    command.option('kill', {\n      description: 'POSIX signal to send to a process when we need it to shut-down.',\n      type: 'string',\n      default: DEFAULT_KILL_SIGNAL,\n      required: false\n    });\n\n    command.option('quiet', {\n      description: 'Suppress all logging except errors and warnings.',\n      type: 'boolean',\n      default: false,\n      required: false\n    });\n\n    command.example('$0 src/main.js', 'Execute \"src/main.js\" using Node, watch \"src\", and re-run when files change.');\n    command.example('$0 --watch /some/dir --bin python /my/script.py', 'Execute \"/my/script.py\" using Python, watch \"/some/dir\", and re-run when files change.');\n\n    return command;\n  },\n  handler: async ({argv}) => {\n    try {\n      const {entrypoint: entry, bin, watch, kill: processShutdownSignal, quiet} = argv;\n\n      if (quiet) {\n        log.configure({level: 'warn'});\n      }\n\n      // Create a Sentinelle instance.\n      const sentinelle = SentinelleFactory({bin, entry, watch, processShutdownSignal});\n\n      // Setup signal handler.\n      initAdeiu(sentinelle);\n\n      // Set up unhandled rejection handler. These can come from child process\n      // event emitters, even though we have proper error handlers set up on\n      // them.\n      process.on('unhandledRejection', err => {\n        log.verbose('Unhandled rejection:', err);\n      });\n\n      // Log current version for debugging.\n      if (log.isLevelAtLeast('verbose')) {\n        const version = await getPackageVersion();\n        log.verbose(log.prefix('version'), log.chalk.green.bold(version));\n      }\n\n      // Start Sentinelle.\n      await sentinelle.start();\n    } catch (err) {\n      log.error(err.message);\n      log.verbose(err.stack.split('\\n').slice(1).join('\\n'));\n      process.exit(1);\n    }\n  }\n});\n\n\nexport default cli.init();\n"],"file":"cli.js"}