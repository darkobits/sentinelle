{"version":3,"sources":["../../src/lib/process-descriptor.ts"],"names":["ProcessDescriptorFactory","bin","args","stdio","shutdownGracePeriod","processDescriptor","_process","_state","_debuggerState","_killReason","_shutdownGracePeriod","_setState","newState","log","silly","chalk","bold","_handleMessage","message","_handleError","err","exitCode","failed","firstLine","fs","readFileSync","command","encoding","split","os","EOL","startsWith","error","ignoreMessages","some","m","String","includes","stack","verbose","slice","join","code","_handleStderrData","chunk","data","Buffer","from","toString","test","kill","_handleClose","signal","red","info","dim","Error","_killAfterGracePeriod","setTimeout","isClosed","getState","awaitClosed","detached","catch","on","stdin","process","pipe","stdout","stderr","endsWith"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport os from 'os';\n\nimport execa from 'execa';\nimport pWaitFor from 'p-wait-for';\nimport log from 'lib/log';\n\nimport {\n  DebuggerState,\n  KillReason,\n  ProcessState,\n  StdioOption\n} from 'etc/types';\n\n\n/**\n * Options object accepted by `ProcessDescriptorFactory`.\n */\nexport interface ProcessDescriptorOptions {\n  /**\n   * Name of the binary to run.\n   */\n  bin: string;\n\n  /**\n   * Array of additional arguments to pass to the binary.\n   */\n  args?: Array<string>;\n\n  /**\n   * Output configuration for the spawned process.\n   */\n  stdio?: StdioOption | Array<StdioOption>;\n\n  /**\n   * Number of milliseconds to wait before forcefully killing a process.\n   */\n  shutdownGracePeriod: number;\n}\n\n\n/**\n * Shape of objects returned by ProcessDescriptorFactory.\n */\nexport interface ProcessDescriptor {\n  /**\n   * Returns the process' state.\n   */\n  getState(): ProcessState;\n\n  /**\n   * Issues a kill command to the process, sets its state to STOPPING, and\n   * returns a promise that resolves when the process has exited.\n   */\n  kill(signal?: NodeJS.Signals): Promise<void>;\n\n  /**\n   * Returns true if the process' state is STOPPED, KILLED, or EXITED.\n   */\n  isClosed(): boolean;\n\n  /**\n   * Returns a Promise that resolves when the process' state becomes one of\n   * STOPPED, KILLED, or EXITED.\n   */\n  awaitClosed(): Promise<void>;\n}\n\n\n/**\n * Returns a new process descriptor representing a managed process and its\n * state.\n */\nexport default function ProcessDescriptorFactory({bin, args, stdio, shutdownGracePeriod}: ProcessDescriptorOptions): ProcessDescriptor {\n  const processDescriptor: Partial<ProcessDescriptor> = {};\n\n\n  /**\n   * @private\n   *\n   * Child process/promise returned by Execa.\n   */\n  // eslint-disable-next-line prefer-const\n  let _process: execa.ExecaChildProcess;\n\n\n  /**\n   * @private\n   *\n   * The managed process' current state.\n   */\n  let _state: ProcessState;\n\n\n  /**\n   * @private\n   *\n   * Tracks the state of Node debugger instances that may be attached to the\n   * process.\n   */\n  let _debuggerState: DebuggerState = 'DISABLED';\n\n\n  /**\n   * @private\n   *\n   * Potential reason for why the process might have been forcefully killed.\n   */\n  let _killReason: KillReason;\n\n\n  /**\n   * @private\n   *\n   * Number of milliseconds to wait before forcefully killing a process.\n   */\n  const _shutdownGracePeriod = shutdownGracePeriod || 4000;\n\n\n  // ----- Private Methods -----------------------------------------------------\n\n  /**\n   * @private\n   *\n   * Sets the process' current state.\n   */\n  const _setState = (newState: ProcessState) => {\n    if (_state !== newState) {\n      _state = newState;\n      log.silly(`Set process state to ${log.chalk.bold(newState)}.`);\n    }\n  };\n\n\n  /**\n   * @private\n   *\n   * Handle the \"message\" event.\n   */\n  const _handleMessage = (message: any) => {\n    log.silly('process', message);\n  };\n\n\n  /**\n   * @private\n   *\n   * Handle the \"error\" event.\n   */\n  const _handleError = <E extends Error & execa.ExecaError & {code: string}>(err: E) => {\n    if (err.exitCode === 2 && err.failed) {\n      const firstLine = fs.readFileSync(err.command, {encoding: 'utf8'}).split(os.EOL)[0];\n\n      if (!firstLine.startsWith('#!')) {\n        log.error('hint', log.chalk.bold('Did you remember to set a shebang in your entrypoint?'));\n        return;\n      }\n    }\n\n    // Error messages from execa that we can safely ignore as they are reported\n    // by us.\n    const ignoreMessages = [\n      'Command failed',\n      'Command was killed with',\n      // Issue appeared in execa 2.0.0 and seems to only occur when detached is\n      // true.\n      'Cannot destructure property `error`'\n    ];\n\n    if (ignoreMessages.some(m => String(err.message).includes(m))) {\n      return;\n    }\n\n    if (err?.stack) {\n      log.error(`Child process error: ${err.message}`);\n      log.verbose(err.stack.split('\\n').slice(1).join('\\n'));\n    }\n\n    if (err.code === 'EACCES') {\n      log.error('hint', log.chalk.bold('Did you remember to set the executable flag on your entrypoint?'));\n    }\n  };\n\n\n  /**\n   * @private\n   *\n   * If the stdio configuration was set to `pipe` for stderr, acts a listener\n   * for stderr's `data` event. This allows us to track the state of Node\n   * debuggers.\n   */\n  const _handleStderrData = (chunk: any) => {\n    const data = Buffer.from(chunk).toString('utf8');\n\n    if (data.includes('Debugger listening on')) {\n      _debuggerState = 'LISTENING';\n      log.verbose(`Set debugger state to ${log.chalk.bold('LISTENING')}.`);\n    }\n\n    if (data.includes('Debugger attached')) {\n      _debuggerState = 'ATTACHED';\n      log.verbose(`Set debugger state to ${log.chalk.bold('ATTACHED')}.`);\n    }\n\n    // This scenario tends to arise when a process exits on its own (re: was not\n    // shut-down) and had a debugger instance attached. Whether or not the\n    // debugger was/is paused, Node will keep the process alive and issue the\n    // below message. When we see this message, we know we can safely kill the\n    // process immediately.\n    if (/waiting for the debugger to disconnect/gi.test(data)) {\n      _debuggerState = 'HANGING';\n      _killReason = 'HANGING_DEBUGGER';\n      // Rather than waiting for the grace period to expire, we should kill\n      // the process immediately. We can safely assume that the process has\n      // exited (as far as the user's code is concerned) because Node only\n      // prints the above message when the code has finished executing _but_\n      // a debugger is still attached.\n      if (typeof processDescriptor.kill === 'function') {\n        void processDescriptor.kill('SIGKILL');\n      }\n    }\n  };\n\n\n  /**\n   * @private\n   *\n   * Handle the (very complex) \"close\" event.\n   */\n  const _handleClose = (code: number, signal: string) => {\n    // ----- Exotic Ungraceful Exits -------------------------------------------\n\n    if (_killReason === 'GRACE_PERIOD_EXPIRED') {\n      // Process took longer than the grace period to shut-down.\n      log.error(log.chalk.red.bold('Process failed to shut-down in time and was killed.'));\n      _setState('KILLED');\n      return;\n    }\n\n    if (signal === 'SIGKILL') {\n      // Process closed as a result of SIGKILL.\n      log.error(log.chalk.red.bold('Process was killed.'));\n      _setState('KILLED');\n      return;\n    }\n\n    if (_killReason === 'PAUSED_DEBUGGER') {\n      // Process was killed because a file change triggered a restart while the\n      // debugger had paused execution.\n      log.info(log.chalk.red.dim.bold('Detected paused debugger; process was killed.'));\n      _setState('KILLED');\n      return;\n    }\n\n    if (_killReason === 'HANGING_DEBUGGER') {\n      // Process had a hanging debugger instnace attached and failed to\n      // shut-down.\n      log.info(log.chalk.red.dim.bold('Detected hanging debugger; process was killed.'));\n      _setState('KILLED');\n      return;\n    }\n\n\n    // ----- Ungraceful Exits --------------------------------------------------\n\n    if (code !== 0 && signal === null) {\n      if (_state === 'STOPPING') {\n        // Process was issued an interrupt signal and crashed within the grace\n        // period.\n        log.error(log.chalk.red.bold('Process crashed while shutting-down.'));\n        _setState('STOPPED');\n        return;\n      }\n\n      if (_state === 'STARTED') {\n        // Process crashed on its own without requiring an interrupt signal.\n        log.error(log.chalk.red.bold(`Process crashed. ${log.chalk.dim(`(Code: ${code})`)}`));\n\n        _setState('EXITED');\n        return;\n      }\n    }\n\n\n    // ----- Graceful Exits ----------------------------------------------------\n\n    if (code === 0 || code === null) {\n      if (_state === 'STOPPING') {\n        // Process was issued an interrupt signal and closed cleanly within the\n        // grace period.\n        log.info(log.chalk.bold('Process shut-down gracefully.'));\n        _setState('STOPPED');\n        return;\n      }\n\n      if (_state === 'STARTED') {\n        // Process exited cleanly on its own without requiring an interrupt\n        // signal.\n        log.info(log.chalk.bold('Process exited cleanly.'));\n        _setState('EXITED');\n        return;\n      }\n    }\n\n    throw new Error(`Unexpected code path in \"close\" handler. Exit code: ${code}; signal: ${signal}; State: ${_state}`);\n  };\n\n\n  /**\n   * @private\n   *\n   * Kills the process after the indicated grace period.\n   */\n  const _killAfterGracePeriod = (signal: NodeJS.Signals) => {\n    setTimeout(() => {\n      // Process has not exited after the grace period and a Node debugger is\n      // attached. It is likely that the process did not exit because the\n      // debugger is paused. In this case, we need to send a SIGKILL to the\n      // process to force it to exit.\n      if (processDescriptor.isClosed && processDescriptor.kill && !processDescriptor.isClosed() && _debuggerState === 'ATTACHED') {\n        _killReason = 'PAUSED_DEBUGGER';\n        void processDescriptor.kill('SIGKILL');\n        return;\n      }\n\n      // Process has not exited after the grace period\n      if (processDescriptor.isClosed && processDescriptor.kill && !processDescriptor.isClosed()) {\n        // Set killReason so `handleClose` knows what happened.\n        _killReason = 'GRACE_PERIOD_EXPIRED';\n        void processDescriptor.kill(signal);\n        return;\n      }\n    }, _shutdownGracePeriod);\n  };\n\n\n  // ----- Public Methods ------------------------------------------------------\n\n  /**\n   * Returns the process' state.\n   */\n  processDescriptor.getState = () => {\n    return _state;\n  };\n\n\n  /**\n   * Returns true if the process' state is STOPPED, KILLED, or EXITED.\n   */\n  processDescriptor.isClosed = () => {\n    return ['STOPPED', 'EXITED', 'KILLED'].includes(_state);\n  };\n\n\n  /**\n   * Returns a Promise that resolves when the process' state becomes one of\n   * STOPPED, KILLED, or EXITED.\n   */\n  processDescriptor.awaitClosed = async () => {\n    if (processDescriptor.isClosed) {\n      return pWaitFor(processDescriptor.isClosed);\n    }\n  };\n\n\n  /**\n   * Sets the process' state to STOPPING, issues a kill command, and returns a\n   * promise that resolves when the process has exited.\n   */\n  processDescriptor.kill = async (signal?: NodeJS.Signals) => {\n    _setState('STOPPING');\n    _process.kill(signal);\n    _killAfterGracePeriod('SIGKILL');\n\n    if (processDescriptor.awaitClosed) {\n      return processDescriptor.awaitClosed();\n    }\n  };\n\n\n  // ----- Init ----------------------------------------------------------------\n\n  _setState('STARTING');\n\n  // Run the child process in detached mode, as this gives us more control over\n  // how signals are passed from us to it.\n  _process = execa(bin, args, {stdio, detached: true});\n\n  // Prevents unhandled rejection warnings and lets us hook into process crash\n  // information that we don't get with the error handler above.\n  _process.catch(_handleError);\n\n  // Set up event handlers.\n  void _process.on('message', _handleMessage);\n  void _process.on('close', _handleClose);\n  void _process.on('error', _handleError);\n\n  // Set up pipes as needed.\n  if (_process.stdin) {\n    process.stdin.pipe(_process.stdin);\n  }\n\n  if (_process.stdout) {\n    _process.stdout.pipe(process.stdout);\n  }\n\n  if (_process.stderr) {\n    _process.stderr.pipe(process.stderr);\n    _process.stderr.on('data', _handleStderrData);\n  } else if (bin.endsWith('node')) {\n    log.verbose('With current stdio configuration, Sentinelle will be unable to detect hanging/paused Node debugger instances.');\n  }\n\n  _setState('STARTED');\n\n  return processDescriptor as Required<ProcessDescriptor>;\n}\n"],"file":"process-descriptor.js"}