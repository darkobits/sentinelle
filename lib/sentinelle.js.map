{"version":3,"sources":["../../src/lib/sentinelle.ts"],"names":["SentinelleFactory","options","sentinelle","bin","ow","any","string","undefined","_bin","log","silly","prefix","entry","_entry","entryArgs","array","ofType","_entryArgs","watch","_watches","path","resolve","dirname","processShutdownGracePeriod","number","_processShutdownGracePeriod","DEFAULT_SHUTDOWN_GRACE_PERIOD","processShutdownSignal","_processShutdownSignal","DEFAULT_KILL_SIGNAL","stdio","_stdio","_watcher","_curProcess","_initWatchers","filteredWatches","reduce","finalWatches","curWatch","warn","forEach","isDir","fs","statSync","isDirectory","info","chalk","bold","green","chokidar","on","start","getState","restart","err","stack","error","message","verbose","split","slice","join","_stopProcess","signal","isClosed","yellow","kill","awaitClosed","binArgs","finalBin","finalArgs","commandAsString","args","shutdownGracePeriod","stop","close"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nimport chokidar from 'chokidar';\nimport ow from 'ow';\n\nimport {DEFAULT_KILL_SIGNAL, DEFAULT_SHUTDOWN_GRACE_PERIOD} from 'etc/constants';\nimport log from 'lib/log';\nimport ProcessDescriptorFactory, {ProcessDescriptor, ProcessDescriptorOptions} from 'lib/process-descriptor';\nimport {ensureArray, ensureBin, ensureFile, parseTime} from 'lib/utils';\n\n\n/**\n * Options that may be provided to `SentinelleFactory`.\n */\nexport interface SentinelleOptions {\n  /**\n   * Entry file for the application or script to manage.\n   */\n  entry: string;\n\n  /**\n   * (Optional) Additional arguments to pass to `entry`.\n   */\n  entryArgs?: Array<string>;\n\n  /**\n   * (Optional) Binary to use to run the application or script.\n   *\n   * Default: node\n   */\n  bin?: string;\n\n  /**\n   * (Optional) Extra files or directories to watch in addition to \"entry\".\n   */\n  watch?: Array<string>;\n\n  /**\n   * (Optional) Time to wait after issuing an interrupt signal to a process\n   * before killing it.\n   *\n   * Default: 4 seconds\n   */\n  processShutdownGracePeriod?: number | string;\n\n  /**\n   * (Optional) Signal to use when shutting-down processes.\n   *\n   * Default: SIGINT\n   */\n  processShutdownSignal?: NodeJS.Signals;\n\n  /**\n   * (Optional) Output configuration for processes.\n   *\n   * Default: 'inherit'\n   */\n  stdio?: ProcessDescriptorOptions['stdio'];\n}\n\n\n/**\n * Object returned by SentinelleFactory.\n */\nexport interface Sentinelle {\n  /**\n   * Waits for any current managed process to become 'STOPPED', then starts a\n   * new managed process and returns its process descriptor.\n   */\n  start(): Promise<void>;\n\n  /**\n   * Restarts the managed process.\n   */\n  restart(signal?: NodeJS.Signals): Promise<void>;\n\n  /**\n   * Closes all file watchers and waits for the current process to close. An\n   * optional signal may be provided which will be sent to the process.\n   */\n  stop(signal?: NodeJS.Signals): Promise<void>;\n}\n\n\n/**\n * Creates a new Sentinelle that will watch a set of files and (re)start a\n * process when they change.\n *\n * TODO: Add our own SIGINT handler to gracefully shut-down the process before\n * exiting.\n */\nexport default function SentinelleFactory(options: SentinelleOptions): Sentinelle {\n  const sentinelle: Partial<Sentinelle> = {};\n\n\n  /**\n   * @private\n   *\n   * (Optional) Name of the binary we will use to execute our entry file. This\n   * will throw if the binary is not present.\n   *\n   * Default: node\n   */\n  ow(options.bin, 'bin', ow.any(ow.string, ow.undefined));\n  const _bin = options.bin;\n  log.silly(log.prefix('bin'), _bin);\n\n  /**\n   * @private\n   *\n   * Name of the entrypoint for the process we will manage. This will throw if\n   * the file is not present or is unreadable.\n   */\n  ow(options.entry, 'entry', ow.string);\n  const _entry = options.entry;\n  log.silly(log.prefix('entry'), _entry);\n\n\n  /**\n   * @private\n   *\n   * (Optional) Additional arguments to pass to `entry`.\n   */\n  ow(options.entryArgs, 'entryArgs', ow.any(ow.undefined, ow.array.ofType(ow.string)));\n  const _entryArgs = ensureArray(options.entryArgs);\n  log.silly(log.prefix('entryArgs'), _entryArgs);\n\n\n  /**\n   * @private\n   *\n   * (Optional) List of files/directories we will watch. By default, this always\n   * contains the directory of our entry file. The user may provide additional\n   * files or directories to watch with the \"watch\" option.\n   */\n  ow(options.watch, 'watch', ow.any(ow.array.ofType(ow.string), ow.undefined));\n  const _watches = [path.resolve(path.dirname(_entry)), ...options.watch ?? []];\n  log.silly(log.prefix('watches'), _watches);\n\n\n  /**\n   * @private\n   *\n   * (Optional) How long to wait for a process to exit on its own after we issue\n   * the configured shut-down signal. Once this period expires, the process will\n   * be forcefully terminated.\n   *\n   * Default: '4 seconds'\n   */\n  ow(options.processShutdownGracePeriod, 'processShutdownGracePeriod', ow.any(ow.string, ow.number, ow.undefined));\n  const _processShutdownGracePeriod = parseTime(options.processShutdownGracePeriod ?? DEFAULT_SHUTDOWN_GRACE_PERIOD) as number;\n  log.silly(log.prefix('gracePeriod'), `${_processShutdownGracePeriod}ms`);\n\n\n  /**\n   * @private\n   *\n   * (Optional) Signal we will send to child processes to indicate we want them\n   * to shut down.\n   *\n   * Default: SIGINT\n   */\n  ow(options.processShutdownSignal, 'processShutdownSignal', ow.any(ow.string, ow.undefined));\n  const _processShutdownSignal = options.processShutdownSignal ?? DEFAULT_KILL_SIGNAL;\n  log.silly(log.prefix('signal'), _processShutdownSignal);\n\n\n  /**\n   * @private\n   *\n   * (Optional) Output options for spawned processes.\n   */\n  ow(options.stdio, 'stdio', ow.any(ow.undefined, ow.string, ow.array.ofType(ow.string)));\n  const _stdio = options.stdio ?? ['inherit', 'inherit', 'pipe'];\n  log.silly(log.prefix('stdio'), _stdio);\n\n\n  /**\n   * @private\n   *\n   * Chokidar instance we will create when we start.\n   */\n  let _watcher: chokidar.FSWatcher | undefined;\n\n\n  /**\n   * @private\n   *\n   * Descriptor for the current managed process.\n   */\n  let _curProcess: ProcessDescriptor;\n\n\n  // ----- Private Methods -----------------------------------------------------\n\n  /**\n   * @private\n   *\n   * Initializes file watchers.\n   */\n  const _initWatchers = () => {\n    if (_watcher) {\n      return;\n    }\n\n    // Ensure we aren't watching anything problematic.\n    const filteredWatches = _watches.reduce<Array<string>>((finalWatches, curWatch) => {\n      if (curWatch === '/') {\n        log.warn('Refusing to recursively watch \"/\"; watching entry file instead.');\n        return [_entry, ...finalWatches];\n      }\n\n      return [...finalWatches, curWatch];\n    }, []);\n\n    filteredWatches.forEach(watch => {\n      const isDir = fs.statSync(watch).isDirectory();\n      log.info(log.chalk.bold(`Watching ${isDir ? 'directory' : 'file'}`), log.chalk.green(`${watch}`));\n    });\n\n    _watcher = chokidar.watch(filteredWatches);\n\n    /**\n     * Called every time we receive a `change` event on a file or directory we\n     * are watching. This function must be implemented in a way that allows it\n     * to be called numerous times, but will only call `startProcess` once, when\n     * the last process has exited.\n     */\n    _watcher.on('change', () => {\n      // If there is no managed process running, start one.\n      if (!_curProcess) {\n        log.silly(log.prefix('change'), 'No process running; starting process.');\n\n        if (typeof sentinelle.start === 'function') {\n          void sentinelle.start();\n        }\n\n        return;\n      }\n\n      // If the current process is in the... process... of shutting-down, bail.\n      if (_curProcess.getState() === 'STOPPING') {\n        log.silly(log.prefix('change'), 'Process is still shutting-down; bailing.');\n        return;\n      }\n\n      if (typeof sentinelle.restart === 'function') {\n        void sentinelle.restart();\n      }\n\n      return;\n    });\n\n    /**\n     * Invoked when the watcher encounters an error.\n     *\n     * TODO: Consider handling this.\n     */\n    _watcher.on('error', err => {\n      if (err?.stack) {\n        log.error('Watcher error:', err.message);\n        log.verbose(err.stack.split('\\n').slice(1).join('\\n'));\n      }\n    });\n  };\n\n\n  /**\n   * @private\n   *\n   * Sends a signal to the managed process and waits for it to become 'STOPPED'.\n   */\n  const _stopProcess = async (signal: NodeJS.Signals = _processShutdownSignal): Promise<void> => {\n    // Bail if there is no process to stop.\n    if (!_curProcess) {\n      log.warn('No process running.');\n      return;\n    }\n\n    // If the process is in such a state that we don't need to stop it, bail.\n    if (_curProcess.isClosed()) {\n      log.verbose('Process is already stopped; nothing to do.');\n      return;\n    }\n\n    if (signal === 'SIGKILL') {\n      log.info(log.chalk.bold('Forcefully stopping process...'));\n    } else {\n      log.info(log.chalk.bold('Stopping process...'));\n    }\n\n    log.silly(`Sending signal ${log.chalk.yellow.bold(signal)} to process.`);\n\n    await _curProcess.kill(signal);\n  };\n\n\n  // ----- Public Methods ------------------------------------------------------\n\n  /**\n   * Waits for any current managed process to become 'STOPPED', then starts a\n   * new managed process and returns its process descriptor.\n   */\n  sentinelle.start = async () => {\n    // Start watchers. If this has already been done, this will be a no-op.\n    _initWatchers();\n\n    // If there was an existing process, Wait until it stops.\n    if (_curProcess && !_curProcess.isClosed()) {\n      log.warn(log.prefix('startProcess'), 'Waiting for process state to become \"STOPPED\".');\n      await _curProcess.awaitClosed();\n    }\n\n    try {\n      // Split-out \"bin\" from any arguments to be passed to it.\n      const [bin, ...binArgs] = _bin ? _bin.split(' ') : ['', ''];\n\n      // Split out \"entry\" from any arguments to be passed to it.\n      const [entry, ...entryArgs] = _entry.split(' ');\n\n      // If using the \"bin\" option, our final executable will be \"bin\".\n      // Otherwise, use \"entry\" directly.\n      const finalBin = bin ? ensureBin(bin) : ensureFile(entry);\n\n      // If \"bin\" is being used, our final arguments array will consist of any\n      // extra arguments to pass to \"bin\", then our \"entry\", then any extra\n      // arguments to pass to \"entry\". If not using \"bin\", our final arguments\n      // array is just any extra arguments to pass to \"entry\".\n      const finalArgs = bin ? [...binArgs, entry, ...entryArgs] : entryArgs;\n\n      // Build a string representing the command we will issue. We use the\n      // original version of \"bin\" here rather than the full path to keep things\n      // readable.\n      const commandAsString = `${bin || entry} ${finalArgs.join(' ')}`;\n      log.info(log.chalk.bold('Starting'), log.chalk.green(commandAsString));\n\n      // Create a new ProcessDescriptor.\n      // eslint-disable-next-line require-atomic-updates\n      _curProcess = ProcessDescriptorFactory({\n        bin: finalBin,\n        args: finalArgs,\n        stdio: _stdio,\n        shutdownGracePeriod: _processShutdownGracePeriod\n      });\n    } catch (err) {\n      log.error(err.message);\n      log.verbose(err.stack.split('\\n').slice(1).join('\\n'));\n    }\n  };\n\n\n  /**\n   * Restarts the managed process.\n   */\n  sentinelle.restart = async (signal: NodeJS.Signals = _processShutdownSignal) => {\n    // If no process has been started, bail.\n    if (!_curProcess) {\n      return;\n    }\n\n    // If the process is not closed, call stopProcess() and wait.\n    if (!_curProcess.isClosed()) {\n      await _stopProcess(signal);\n    }\n\n    if (typeof sentinelle.start === 'function') {\n      await sentinelle.start();\n    }\n  };\n\n\n  /**\n   * Closes all file watchers and waits for the current process to close. An\n   * optional signal may be provided which will be sent to the process.\n   */\n  sentinelle.stop = async (signal: NodeJS.Signals = _processShutdownSignal) => {\n    if (!_curProcess) {\n      return;\n    }\n\n    log.verbose('Shutting down.');\n\n    // Close watchers.\n    if (_watcher) {\n      await _watcher.close();\n      // eslint-disable-next-line require-atomic-updates\n      _watcher = undefined;\n      log.silly('My watch has ended.');\n    }\n\n    // Close process.\n    log.silly(`Stopping process with signal ${log.chalk.bold(signal)}.`);\n    await _stopProcess(signal);\n  };\n\n\n  return sentinelle as Required<Sentinelle>;\n}\n"],"file":"sentinelle.js"}