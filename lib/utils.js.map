{"version":3,"sources":["../../src/lib/utils.ts"],"names":["isNumerical","value","test","String","parseTime","Number","parseInt","ensureBin","name","binFinder","os","platform","encoding","trim","err","message","toLowerCase","includes","Error","ensureFile","absPath","path","resolve","fs","accessSync","constants","R_OK","code","ensureArray","Array","isArray","undefined","getPackageVersion","pkgInfo","cwd","__dirname","packageJson","version","randomArrayElement","xs","Math","floor","random","length"],"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;AAMO,SAASA,WAAT,CAAqBC,KAArB,EAAiC;AACtC,SAAO,CAAC,MAAMC,IAAN,CAAWC,MAAM,CAACF,KAAD,CAAjB,CAAR;AACD;;AAcM,SAASG,SAAT,CAAmBH,KAAnB,EAA4C;AAEjD,MAAI,CAACA,KAAD,IAAU,CAACD,WAAW,CAACC,KAAD,CAA1B,EAAmC;AACjC;AACD;;AAED,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,QAAID,WAAW,CAACC,KAAD,CAAf,EAAwB;AACtB,aAAOI,MAAM,CAACC,QAAP,CAAgBL,KAAhB,EAAuB,EAAvB,CAAP;AACD;;AAID,WAAO,iBAAGA,KAAH,CAAP;AACD;;AAED,SAAOA,KAAP;AACD;;AAOM,SAASM,SAAT,CAAmBC,IAAnB,EAAiC;AACtC,QAAMC,SAAS,GAAGC,YAAGC,QAAH,OAAkB,OAAlB,GAA4B,OAA5B,GAAsC,OAAxD;;AAEA,MAAI;AACF,WAAO,6BAAU,GAAEF,SAAU,IAAGD,IAAK,EAA9B,EAAiC;AAACI,MAAAA,QAAQ,EAAE;AAAX,KAAjC,EAAqDC,IAArD,EAAP;AACD,GAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,QAAIA,GAAG,SAAH,IAAAA,GAAG,WAAH,IAAAA,GAAG,CAAEC,OAAL,IAAgBD,GAAG,CAACC,OAAJ,CAAYC,WAAZ,GAA0BC,QAA1B,CAAmC,gBAAnC,CAApB,EAA0E;AACxE,YAAM,IAAIC,KAAJ,CAAW,eAAcV,IAAK,iCAA9B,CAAN;AACD;;AAED,UAAMM,GAAN;AACD;AACF;;AAMM,SAASK,UAAT,CAAoBX,IAApB,EAAkC;AACvC,QAAMY,OAAO,GAAGC,cAAKC,OAAL,CAAad,IAAb,CAAhB;;AAEA,MAAI;AACFe,gBAAGC,UAAH,CAAcJ,OAAd,EAAuBG,YAAGE,SAAH,CAAaC,IAApC;;AACA,WAAON,OAAP;AACD,GAHD,CAGE,OAAON,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACa,IAAJ,KAAa,QAAjB,EAA2B;AACzB,YAAM,IAAIT,KAAJ,CAAW,aAAYE,OAAQ,uBAA/B,CAAN;AACD;;AAED,QAAIN,GAAG,CAACa,IAAJ,KAAa,QAAjB,EAA2B;AACzB,YAAM,IAAIT,KAAJ,CAAW,aAAYE,OAAQ,yCAA/B,CAAN;AACD;;AAED,UAAMN,GAAN;AACD;AACF;;AAOM,SAASc,WAAT,CAAwB3B,KAAxB,EAA0E;AAC/E,MAAI4B,KAAK,CAACC,OAAN,CAAc7B,KAAd,CAAJ,EAA0B;AACxB,WAAOA,KAAP;AACD;;AAED,MAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK8B,SAAhC,EAA2C;AACzC,WAAO,EAAP;AACD;;AAED,SAAO,CAAC9B,KAAD,CAAP;AACD;;AAOM,eAAe+B,iBAAf,GAAmC;AACxC,QAAMC,OAAO,GAAG,MAAM,wBAAU;AAACC,IAAAA,GAAG,EAAEC;AAAN,GAAV,CAAtB;;AAEA,MAAI,CAACF,OAAL,EAAc;AACZ,UAAM,IAAIf,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAGD,SAAOe,OAAO,CAACG,WAAR,CAAoBC,OAA3B;AACD;;AAMM,SAASC,kBAAT,CAAqCC,EAArC,EAAsD;AAC3D,SAAOA,EAAE,CAACC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBH,EAAE,CAACI,MAA9B,CAAD,CAAT;AACD","sourcesContent":["import {execSync} from 'child_process';\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\nimport ms from 'ms';\nimport readPkgUp from 'read-pkg-up';\n\n\n/**\n * Returns true if the provided string _only_ contains digits.\n */\nexport function isNumerical(value: any) {\n  return !/\\D/g.test(String(value));\n}\n\n\n/**\n * Provided a string or number representing an interval of time, returns the\n * number of milliseconds in that interval.\n *\n * Example:\n *\n * '5m'     //=> 300000\n * '300000' //=> 300000\n * 300000   //=> 300000\n * 'foo'    //=> undefined\n */\nexport function parseTime(value?: string | number) {\n  // Covers `null`, `undefined`, `false`.\n  if (!value && !isNumerical(value)) {\n    return;\n  }\n\n  if (typeof value === 'string') {\n    if (isNumerical(value)) {\n      return Number.parseInt(value, 10);\n    }\n\n    // The type definitions for `ms` do not indicate that it returns `undefined`\n    // on invaid input, so we have to explicitly type it here.\n    return ms(value) as number | undefined;\n  }\n\n  return value;\n}\n\n\n/**\n * Provided the name of a binary, returns the path to that binary if it is\n * present on the system and locatable via the user's shell.\n */\nexport function ensureBin(name: string) {\n  const binFinder = os.platform() === 'win32' ? 'where' : 'which';\n\n  try {\n    return execSync(`${binFinder} ${name}`, {encoding: 'utf8'}).trim();\n  } catch (err) {\n    if (err?.message && err.message.toLowerCase().includes('command failed')) {\n      throw new Error(`The binary \"${name}\" was not found on your system.`);\n    }\n\n    throw err;\n  }\n}\n\n\n/**\n * Provided the path to/name of a file, ensures the file exists and is readable.\n */\nexport function ensureFile(name: string) {\n  const absPath = path.resolve(name);\n\n  try {\n    fs.accessSync(absPath, fs.constants.R_OK);\n    return absPath;\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      throw new Error(`The file \"${absPath}\" could not be found.`);\n    }\n\n    if (err.code === 'EACCES') {\n      throw new Error(`The file \"${absPath}\" could not be read; permission denied.`);\n    }\n\n    throw err;\n  }\n}\n\n\n/**\n * If the provided value is an array, returns it. Otherwise, wraps the value in\n * an array and returns it.\n */\nexport function ensureArray<T>(value: T | Array<T> | null | undefined): Array<T> {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  if (value === null || value === undefined) {\n    return [];\n  }\n\n  return [value];\n}\n\n\n/**\n * Returns a Promise that resolves with the current \"version\" from our\n * package.json.\n */\nexport async function getPackageVersion() {\n  const pkgInfo = await readPkgUp({cwd: __dirname});\n\n  if (!pkgInfo) {\n    throw new Error('Unable to locate a package.json for Senintlle.');\n  }\n\n\n  return pkgInfo.packageJson.version;\n}\n\n\n/**\n * Returns a random element from the provided array.\n */\nexport function randomArrayElement<T = any>(xs: Array<T>): T {\n  return xs[Math.floor(Math.random() * xs.length)];\n}\n"],"file":"utils.js"}